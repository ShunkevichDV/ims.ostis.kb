<p>Erlang (Эрланг) — функциональный язык программирования, позволяющий писать программы для разного рода распределённых систем. Разработан и поддерживается компанией Ericsson. Язык включает в себя средства порождения параллельных процессов и их коммуникации с помощью посылки асинхронных сообщений. Программа транслируется в байт-код, исполняемый виртуальной машиной, что обеспечивает переносимость.
</p>
<p>Язык динамический. Синтаксис наследован от Prolog &#8212; компактный, содержит минимум конструкций, лёгкий для освоения, но не примитивный.
</p>
<p>К услугам программиста — модули, полиморфные функции, сопоставление с образцом, анонимные функции, условные конструкции, структуры, обработка исключений, оптимизация хвостовой рекурсии. В общем базовый арсенал современных функциональных языков.
</p>
<p>Функциональная парадигма (отсутствие присваиваний) позволяет Erlang избежать таких традиционных для императивных языков проблем распределенных приложений, как необходимость синхронизации, опасность возникновения тупиков и гонок.
</p>
<p>Главное в Erlang — его модель легковесных процессов. Перефразируя для Erlang слоган текущего дня &#8220;Everything is an object&#8221; («Всё является объектом»), можно сказать &#8220;Everything is a process&#8221; («Всё является процессом»).
</p>
<p>Процессы дёшевы, создание процесса занимает не больше ресурсов, чем вызов функции. Единственным способом взаимодействия процессов является асинхронный обмен сообщениями.
</p>
<p>Процесс имеет свой «почтовый ящик», откуда может выборочно читать сообщения, в чем очень помогает сопоставление по шаблону, код проверки «ящика» чем-то похож на программу на awk, нужное выгребается и обрабатывается, остальное остаётся или выбрасывается.
</p>
<p>На разработку программ накладывают сильный отпечаток два момента^
</p>
<ul>
 <li>
     язык стимулирует к созданию большого количества конкурентных процессов
 </li>

 <li>
     процессы жёстко изолированы и не имеют общего состояния
 </li>
</ul>
<p>Процесс проектирования заключается в итеративном разбиении системы на иерархии конкурентно взаимодействующих подсистем, пока составляющие не станут достаточно просты для реализации.
</p>
<p>Мощность связки «Процессы+сообщения» не меньше, чем «Объекты+Интерфейсы+Наследование», но зачастую приводит к более компактным и понятным решениям. Устранение конкуренции также просто как и создание. Отсутствие необходимости блокировки доступа к состоянию процесса для синхронизации их взаимодействия сильно облегчает жизнь. Для конкурентного ресурса обычно просто создаётся процесс-монитор, через который осуществляется взаимодействие с ресурсом.
</p>
<p>Второй момент выражается в формуле «let it crash» («пусть процесс упадет»). Вместо перехвата ошибок и попытки продолжения работы часть программы, содержащая рискованный код, выделяется в отдельный процесс-камикадзе, этот процесс делает все возможное, чтобы система убила его в случае возникновения ошибки, а процесс-родитель только получает сообщения о смерти таких незадачливых потомков и делает выводы.
</p>
<p>Учитывая, что обычно в 90 % подобных ситуаций ничего более путного, чем вывести сообщение об ошибке и попытаться жить с этой болью дальше, не представляется возможным, отсутствие в коде многочисленных проверок не так уж непривлекательно.
</p>

<h3>Распределённое взаимодействие</h3>
<p>Запущенный экземпляр эмулятора Erlang называется узлом (node). Узел имеет имя и «знает» о существовании других узлов на данной машине или в сети.
</p>
<p>Создание и взаимодействие процессов разных узлов не отличается от взаимодействия процессов внутри узла. Для создания процесса на другом узле процессу достаточно знать его имя и, без особых на то оснований, он может не интересоваться физическим расположением взаимодействующего с ним процесса.
</p>