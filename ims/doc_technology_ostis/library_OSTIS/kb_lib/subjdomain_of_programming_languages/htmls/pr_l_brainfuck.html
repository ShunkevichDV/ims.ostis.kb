<p>Brainfuck — один из известнейших эзотерических языков программирования, отличающийся особым минимализмом. Состоит из восьми команд, каждая из которых записывается одним символом.
</p>
<p>Brainfuck был создан в 1993 году Урбаном Мюллером (Urban Müller), и авторская реализация остается фактическим стандартом языка. Его базовая спецификация достаточно проста, и он не был стандартизирован. Существует ряд любительских реализаций, ни одна из которых не представляет коммерческой ценности.
</p>
<p>Brainfuck породил множество диалектов, отличающихся набором команд, способом их записи или деталями реализации, например, максимальным значением числа, хранящегося в ячейке, или ситуациями, вызывающими ошибку интерпретации.
</p>
<p>Brainfuck был изобретен при попытке создать Тьюринг-полный язык программирования с наименьшим возможным компилятором. Авторский компилятор имел размер 240 байт, а более поздние реализации достигают менее 200 байт.
</p>
<p>Теоретически Brainfuck действительно обладает свойством Тьюринг-полноты и следовательно, может выполнить любую задачу. На практике, впрочем, этот язык совершенно непригоден для решения задач из реальной жизни; выполнение даже простейших заданий становится вызовом для разработчика. Поэтому Brainfuck используется исключительно как математическая модель или для развлечения.
</p>
<p>Создателя Brainfuck вдохновил язык FALSE, а его 6 команд (за исключением команд ввода-вывода) в точности совпадают с командами языка P&#8221;, но остается неизвестным, влиял ли последний на разработку Brainfuck.
</p>
<p>Brainfuck использует модель машины, напоминающую машину Тьюринга и состоящую из следующих элементов:
</p>
<ul>
 <li>
     программа &#8212; последовательность односимвольных команд языка и, возможно, других символов (при обработке игнорируются);
 </li>

 <li>
     указатель инструкций &#8212; указывает на команду, которая будет исполнена на следующем шагу, после ее исполнения передвигается на другую (обычно следующую справа) команду;
 </li>

 <li>
     память &#8212; моделируется одномерным массивом ячеек, в каждой ячейке хранится один байт; начальное значение ячейки &#8212; ноль;
 </li>

 <li>
     указатель данных &#8212; указывает на текущую ячейку памяти; начальное значение &#8212; самая левая ячейка массива; по команде двигается либо изменяет значение, хранящееся в текущей ячейке;
 </li>

 <li>
     потоки ввода и вывода &#8212; последовательности байтов в кодировке ASCII.
 </li>
</ul>
<p>Команды языка:
</p>
<ul>
 <li>
     <code>+</code> : увеличить на 1 значение в текущей ячейке;
 </li>

 <li>
     <code>-</code> : уменьшить на 1 значение в текущей ячейке;
 </li>

 <li>
     <code>&gt;</code> : сдвинуть указатель данных на одну ячейку вправо;
 </li>

 <li>
     <code>&lt;</code> : сдвинуть указатель данных на одну ячейку влево;
 </li>

 <li>
     <code>[</code> : &#8220;начало цикла&#8221;: если значение в текущей ячейке положительно, сдвинуть указатель инструкций на одну команду вправо, иначе сдвинуть его на команду, следующую за парной командой <code>]</code>;
 </li>

 <li>
     <code>]</code> : &#8220;конец цикла&#8221;: если значение в текущей ячейке нулевое, сдвинуть указатель инструкций на одну команду вправо, иначе иначе сдвинуть его на команду, следующую за парной командой <code>[</code>. Может также быть представлен как безусловный переход указателя инструкций на парную команду <code>[</code>, т.к. <code>[</code> выполняет отдельную проверку на вход в тело цикла;
 </li>

 <li>
     <code>.</code> : вывести значение в текущей ячейке в поток вывода как символ с соответствующим ASCII-кодом;
 </li>

 <li>
     <code>,</code> : прочитать символ из потока ввода и сохранить его ASCII-код в текущую ячейку.
 </li>
</ul>
<p>Следует отметить, что из-за специфики языка команды условного перехода <code>[</code> и <code>]</code> используются при реализации практически всех операций, являющихся элементарными в других языках (присвоение значения, математические и логические операции и т.д.).
</p>
<p>Все символы, кроме восьми командных, обычно игнорируются при обработке, так что комментарии, не содержащие этих символов, могут добавляться в любое место программы без ограничений.
</p>