<p>Assembler — язык программирования низкого уровня, представляющий собой формат записи машинных команд, удобный для восприятия человеком. 
</p>
<p>Команды языка ассемблера один в один соответствуют командам процессора и, фактически, представляют собой удобную символьную форму записи (мнемокод) команд и их аргументов. Также язык ассемблера обеспечивает базовые программные абстракции: связывание частей программы и данных через метки с символьными именами и директивы.
</p>
<p>Директивы ассемблера позволяют включать в программу блоки данных (описанные явно или считанные из файла); повторить определённый фрагмент указанное число раз; компилировать фрагмент по условию; задавать адрес исполнения фрагмента, менять значения меток в процессе компиляции; использовать макроопределения с параметрами и др.
</p>
<p>Каждая модель процессора, в принципе, имеет свой набор команд и соответствующий ему язык (или диалект) ассемблера.
</p>

<h3>Достоинства и недостатки</h3>
<ul>
 <li>
     минимальное количество избыточного кода (использование меньшего количества команд и обращений в память). Как следствие — большая скорость и меньший размер программы
 </li>

 <li>
     большие объемы кода, большое число дополнительных мелких задач 
 </li>

 <li>
     плохая читабельность кода, трудность поддержки (отладка, добавление возможностей)
 </li>

 <li>
     трудность реализации парадигм программирования и любых других сколько-нибудь сложных конвенций, сложность совместной разработки
 </li>

 <li>
     меньшее количество доступных библиотек, их малая совместимость
 </li>

 <li>
     непосредственный доступ к аппаратуре: портам ввода-вывода, особым регистрам процессора
 </li>

 <li>
     возможность написания самомодифицирующегося кода (т.е. метапрограммирования, причем без необходимости программного интерпретатора)
 </li>

 <li>
     максимальная «подгонка» для нужной платформы (использование специальных инструкций, технических особенностей «железа»)
 </li>

 <li>
     непереносимость на другие платформы (кроме двоично совместимых).
 </li>
</ul>

<h3>Синтаксис</h3>
<p>Общепринятого стандарта для синтаксиса языков ассемблера не существует. Однако, существуют стандарты де-факто —  традиционные подходы, которых придерживаются большинство разработчиков языков ассемблера. Основными такими стандартами являются Intel-синтаксис и AT&amp;T-синтаксис.
</p>
<p>Общий формат записи инструкций одинаков для обоих стандартов:
</p>
<pre><code>`[метка:] опкод [операнды] [;комментарий]`
</code></pre><p>Опкод — непосредственно мнемоника инструкции процессору. К ней могут быть добавлены префиксы (повторения, изменения типа адресации и пр.). В качестве операндов могут выступать константы, названия регистров, адреса в оперативной памяти и пр.. Различия между стандартами Intel и AT&amp;T касаются, в основном, порядка перечисления операндов и их синтаксиса при различных методах адресации.
</p>
<p>Используемые мнемоники обычно одинаковы для всех процессоров одной архитектуры или семейства архитектур (среди широко известных &#8212; мнемоники процессоров и контроллеров Motorola, ARM, x86). Они описываются в спецификации процессоров. 
</p>
<p>Например, процессор Zilog Z80 наследовал систему команд Intel i8080, расширил ее и поменял мнемоники (и обозначения регистров) на свой лад. Например, сменил интеловские <code>mov</code> на <code>ld</code>. Процессоры Motorola Fireball наследовали систему команд Z80, несколько её урезав. Вместе с тем, Motorola официально вернулась к мнемоникам Intel. и в данный момент половина ассемблеров для Fireball работает с интеловскими мнемониками, а половина с мнемониками Zilog.
</p>

<h3>Директивы</h3>
<p>Кроме инструкций, программа может содержать директивы: команды, не переводящиеся непосредственно в машинные инструкции, а управляющие работой компилятора. Набор и синтаксис их значительно разнятся и зависят не от аппаратной платформы, а от используемого компилятора (порождая диалекты языков в пределах одного семейства архитектур). В качестве набора директив можно выделить:
</p>
<ul>
 <li>
     определение данных (констант и переменных)
 </li>

 <li>
     управление организацией программы в памяти и параметрами выходного файла
 </li>

 <li>
     задание режима работы компилятора
 </li>

 <li>
     всевозможные абстракции (т.е. элементы языков высокого уровня) —  от оформления процедур и функций (для упрощения реализации парадигмы процедурного программирования) до условных конструкций и циклов (для парадигмы структурного программирования)
 </li>

 <li>
     макросы
 </li>
</ul>

<h3>Происхождение и критика термина «язык ассемблера»</h3>
<p>Данный тип языков получил свое название от названия транслятора (компилятора) с этих языков — ассемблера (англ. assembler — сборщик). Название последнего обусловлено тем, что на первых компьютерах не существовало языков более высокого уровня, и единственной альтернативой созданию программ с помощью ассемблера было программирование непосредственно в кодах.
</p>
<p>Язык ассемблера в русском языке часто называют «ассемблером» (а что-то связанное с ним — «ассемблерный»), что, согласно английскому переводу слова, неправильно, но вписывается в правила русского языка. Однако, сам ассемблер (программу) тоже называют просто «ассемблером», а не «компилятором языка ассемблера» и т. п.
</p>
<p>Использование термина «язык ассемблера» также может вызвать ошибочное мнение о существовании единого языка низкого уровня, или хотя бы стандарта на такие языки. При именовании языка, на котором написана конкретная программа, желательно уточнять, для какой архитектуры она предназначена и на каком диалекте языка написана.
</p>