<p>Язык является надмножеством языка C (любой C код компилируется Objective-C компилятором). В язык добавлены: поддержка объектно-ориентированного программирования в стиле Smalltalk (посылка сообщения вместо вызова метода), строки, логический тип (<code>BOOL</code>, значения <code>YES</code> или <code>NO</code>),  и др.
</p>
<p>Язык отличается от C++ большей гибкостью и количеством метаинформации. При каждом вызове метода Objective-C runtime просматривает таблицу виртуальных методов в поисках нужного селектора. Если метод не найден, вызывается универсальный обработчик. У обычных объектов этот обработчик сигнализирует об ошибке (например, выбросом исключения). А у прокси–объектов этот обработчик конструирует удалённый вызов. Сделать прокси в Objective C относительно просто. Метаинформация об объектах содержит сведения о методах и типах аргументов. Достаточно сведений, чтобы прокси объект мог корректно интерпретировать содержимое стека и сериализовать вызов.
</p>
<p>На низком уровне вызов метода выглядит как вызов objc_sendmsg(object, selector, arguments). Селектор — это строка, состоящая из идентификаторов, разделённых двоеточиями. Например, если вызов имеет вид:
</p>
<p>[mycalendar ordinalityOfUnit:myunit inUnit:myunit2 forDate:mydate]
</p>
<p>&#8230;то селектор этого вызова &#8220;ordinalityOfUnit:inUnit:forDate:&#8221;. Непосредственно в objc_sendmsg передаётся не строка, а 32-битное число. Каждая динамическая библиотека и сама программа при инициализации регистрируют все используемые селекторы, устанавливая соответствие между строками и числами.
</p>
<p>arguments — это varargs языка C.
</p>
<p>Такой способ вызова позволяет частично бороться с проблемой fragile base class. С одной стороны, API системы подлинно объектно–ориентированное. Например, любая Cocoa-программа содержит наследников NSController, который реализован в системной инфраструктуре. С другой стороны, можно относительно легко добавлять новые API к уже существующим классам, являющимися базовыми для пользовательских программ. Именно так Apple и вводит новые API. Пользовательские программы, будь то Camino или Roxio Toast Titanium, не требуют при этом никакой перекомпиляции. Неполнота этого подхода заключается в том, что можно добавлять новые методы, но нельзя добавлять новые поля. Чтобы бороться с этим ограничением, либо с самого начала резервируется достаточно места на будущее, либо создаётся поле типа id, содержащее указатель на внутреннюю реализацию.
</p>
<p>По аналогии с интерфейсами в Java, в Objective C есть протоколы. Протокол определяет набор селекторов, которые должен поддерживать объект, реализующий протокол.
</p>
<p>В языке определён специальный тип id. id отличается от void<em> только тем, что компилятор позволяет вызывать методы id, но не позволяет делать это для void</em>. Во время выполнения любой указатель на объект не отличим от id. Вся разница во время компиляции. Во время компиляции компилятор проверяет поддержку селектора у класса объекта. Например, если переменная имеет тип NSController*, компилятор сделает предупреждение при попытке вызвать неизвестный селектор. Предупреждение сделает, но скомпилировать всё же позволит. Это может быть полезно, если объект являет потомком NSController или вообще не является NSController, что вполне возможно. Поскольку работа со всеми объектами происходит через указатели, а приведение типов для объектов влияет только на восприятие объекта компилятором (никаких runtime проверок), становится возможным использовать утиную типизацию. Используя функции библиотеки Objective C (начинаются на objc_), в принципе, можно выяснить подлинную природу объекта, но компилятор автоматически такие проверки не создаёт.
</p>
<p>Для создания объекта в Objective-C необходимо вызвать метод класса (похожая схема используется в Ruby). Это делает использование таких паттернов, как абстрактная фабрика или синглтон (одиночка), тривиальными.
</p>
<p>Другие особенности:
</p>
<p>Для строковых литералов используется запись вида @&#8221;строка&#8221;. Это создаёт строку типа NSString, а не char*, как в C.
</p>
<p>Вместо директивы #include для заголовочных файлов Objective-C рекомендуется использовать директиву #import, которая гарантированно подключает заголовочный файл только один раз.
</p>
<p>Несколько изменена схема поиска файла заголовка с учётом каркасов (framework). Каркас — это папка, имеющая расширение .framework. Внутри каркаса могут подпапки (или символические ссылки на них) Headers, Resources, Frameworks. Препроцессор при обработке #import &lt;Cocoa/Cocoa.h&gt; находит файл Cocoa.framework/Headers/Cocoa.h Препроцессор без поддержки каркасов не сможет найти этот файл.
</p>